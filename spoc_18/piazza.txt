【说明】
信号量和管程两种同步机制，在相同的代码框架下进行模拟（使用了Python的Threading包）。本框架可以输出课上推荐的输出形式，便于查看进程执行状态。由于这里的空间有限，粘贴之后一行放不下，因此请点击上面的链接查看输出结果。
 
代码非常容易读懂，因此这里只做简单的说明。事实上，管程的写优先策略、信号量的读优先策略，课程中已经讲过了，可以直接对照讲义实现。管程的读优先策略，需要对判定条件做一下更改即可。信号量的读优先策略则复杂一些，需要加一些全局量：
（1）QueueMutex：读写的等待队列。和WriteMutex表示对文件资源的占用不同，这个锁是在“读者”和“写者”两类程序中交替的。只要有等待状态的写者，这个锁就一直被写者持有，读者拿不到该锁就什么都不能做，处于饥饿状态。而读者取得该锁之后，会在进入读操作之前就释放掉（此时文件访问资源由读者占据，释放QueueMutex是为了让此时写者能够尽快抢到资源），由此实现写优先。
（2）Wcount：对写者计数，即辅助实现上面所说的“有写者等待”的条件。
（3）WcountMutex：对写者计数进行保护的信号量。
 
我们的测试用例中，使用两个数表示读写任务：（任务开始时间，任务持续时间）
对应于代码中的reader和writer两个列表。
 
我们设计的三读者三写者的测试用例虽然简单，但能够检查所有要点：
（1）同一时刻只能有一个写者或多个读者访问文件；
（2）读优先时，一旦读者拿到资源，且读者源源不断来，写者就得一直等着；
（3）写优先时，先来的读者可以做，但是在写者之后来的读者就要等到写者全做完才能访问文件；
（4）写优先时，如果没有写者就绪，仍然能够有多个读者同时访问文件；
 
注意，两种实现方式的调度过程是完全一致的，只是中间输出的有关信号量的信息有所不同。